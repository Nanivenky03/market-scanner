## V1.5 CALENDAR DESIGN — REQUIREMENT VALIDATION

### REQUIREMENT CHECKLIST

#### A. TRADING CALENDAR SERVICE STRUCTURE

- ✅ **Interface Proposed**: TradingCalendarService with clear methods:
  - `getSession(LocalDate)` → SessionType
  - `isTradingDay(LocalDate)` → boolean
  - `nextTradingDay(LocalDate)` → LocalDate
  - `previousTradingDay(LocalDate)` → LocalDate
  - `addTradingDays(LocalDate, int)` → LocalDate
  - `tradingDaysBetween(LocalDate, LocalDate)` → int
  - `calendarDaysBetween(LocalDate, LocalDate)` → long

- ✅ **No Database Dependency**: Service is 100% in-memory and read-only

- ✅ **No Price Table Dependency**: Zero queries to stock_prices

- ✅ **Stateless**: No instance state, fully immutable

---

#### B. NSE HOLIDAY CALENDAR STRUCTURE

- ✅ **Enum-Based**: SessionType exhaustive (TRADING, SPECIAL_SESSION, HOLIDAY, UNEXPECTED_CLOSURE, WEEKEND)

- ✅ **Static Model**: NseHolidayCalendar uses unmodifiable Map for 2023-2026

- ✅ **Hardcoded Data**: All NSE holidays statically defined (not imported)

- ✅ **Two-Layer Architecture**:
  - Layer 1: Static calendar (known holidays)
  - Layer 2: Runtime emergencies (volatile set, no persistence)

- ✅ **Mutually Exclusive Sessions**: Each date maps to exactly one SessionType

---

#### C. SPECIAL TRADING SESSION MODELING

- ✅ **Dedicated Enum Value**: SessionType.SPECIAL_SESSION

- ✅ **Characteristics Defined**:
  - Different rules (e.g., Muhurat: shorter hours)
  - IS counted as trading day (`isTradingSession()` returns true)
  - Provider can return data (system handles no-data gracefully)
  - Scanner behavior configurable (skip or process)

- ✅ **Example**: 2023-11-12, 2024-11-01 marked as SPECIAL_SESSION

- ✅ **Extensible**: Ready for session metadata (start/end times) in future

---

#### D. UNEXPECTED SHUTDOWN DAY REPRESENTATION

- ✅ **Runtime Set**: `emergencyClosures` Set<LocalDate> in NseHolidayCalendar

- ✅ **Admin API**: `markUnexpectedClosure()`, `clearUnexpectedClosure()`

- ✅ **No Database**: Volatile (resets on app restart) - appropriate for crisis

- ✅ **Precedence**: Emergency closures override static calendar

- ✅ **Audit Trail**: All admin actions logged at WARN level

---

#### E. SIMULATION STATE CHANGES

- ✅ **New Field**: `tradingOffset` (Integer) added to SimulationState

- ✅ **Semantics Clear**: 
  - offsetDays=0 → baseDate
  - offsetDays=1 → first trading day after base
  - offsetDays=-1 → NOT ALLOWED (forward-only)

- ✅ **Method Signature**: `getCurrentDate(TradingCalendarService calendar)` requires calendar

- ✅ **Advancement**: `advanceOneSession()` increments trading offset

- ✅ **Fast-Forward**: `toTradingDay(LocalDate target, TradingCalendarService)` supported

- ✅ **Reset**: `resetToBase()` for testing

- ✅ **Validation**: `validateBaseDate()` ensures base is trading day

---

#### F. TRADING CALENDAR DOESN'T INFER FROM PROVIDER

- ✅ **CONFIRMED**: Zero dependency on stock_prices table

- ✅ **CONFIRMED**: Zero dependency on Yahoo Finance API

- ✅ **CONFIRMED**: Information flows one-way: Calendar → Ingestion (never reverse)

- ✅ **CONFIRMED**: Holiday list is complete and independent

- ✅ **Worst Case**: If holiday missing, provider returns no-data → system handles gracefully

---

#### G. addTradingDays() BEHAVIOR FOR NEGATIVE VALUES

- ✅ **Negative Support**: addTradingDays(date, -N) goes backward N trading sessions

- ✅ **Zero Handling**: addTradingDays(date, 0) returns date only if trading day, else throws

- ✅ **Forward Handling**: addTradingDays(date, +N) goes forward N trading sessions

- ✅ **Edge Cases**:
  - Non-trading base with count=0 → IllegalStateException
  - Exhausted future/past (100+ years) → TimelineExhaustedException
  - Cannot rewind SimulationState (checked by controller)

---

#### H. EDGE CASE BEHAVIOR

- ✅ **Case 1: Startup on Non-Trading Day**
  - Detection: `validateBaseDate()` in SimulationState
  - Behavior: Throws IllegalStateException at @PostConstruct
  - Resolution: Admin sets simulation.baseDate to next trading day in properties
  - Log: ERROR level, clear message

- ✅ **Case 2: Incomplete Holiday List**
  - Detection: None needed (graceful degradation)
  - Behavior: System treats missing date as TRADING, provider returns no data
  - Outcome: SUCCESS_NO_DATA recorded (correct)
  - Fix: Manual update to NseHolidayCalendar (requires code change + restart)
  - Acceptable because: holidays are known in advance

- ✅ **Case 3: Holiday List Becomes Stale**
  - Scenario: 2027 holidays not yet added
  - Behavior: Treats unmapped date as TRADING → provider returns empty → SUCCESS_NO_DATA
  - Workaround: `markUnexpectedClosure()` admin API (temporary until code updated)
  - Fix: Update static calendar in NseHolidayCalendar → rebuild → restart

---

#### I. INGESTION LOGIC REMAINS UNCHANGED

- ✅ **CONFIRMED**: DataIngestionService requires zero modifications for v1.5

- ✅ **CONFIRMED**: Gap detection uses calendar days (ChronoUnit.DAYS), not trading days

- ✅ **CONFIRMED**: Provider remains agnostic to calendar

- ✅ **CONFIRMED**: No ingestion scheduling changes

- ✅ **Usage of Calendar**: Only `tradingCalendar.calendarDaysBetween()` (new but calendar-agnostic)

```java
// No change to existing logic
long daysSinceLastData = calendar.calendarDaysBetween(latestDate, endDate);
// Still counts all days including weekends/holidays
// Provider decides if data exists
```

---

#### J. FUTURE PROVIDER SWITCH WON'T REQUIRE CALENDAR REDESIGN

- ✅ **Architecture Supports**: 
  - Calendar is injected (not hardcoded)
  - Future: Create BseHolidayCalendar, NyseHolidayCalendar, etc.
  - Spring can select via configuration

- ✅ **Ingestion Unaffected**: Uses calendar interface, not NSE-specific code

- ✅ **Scanner Unaffected**: Uses dates, not calendar-specific logic

- ✅ **Simulation Unaffected**: Uses injected calendar, works with any exchange

- ✅ **Zero Breaking Changes**: Only DI configuration changes per exchange

---

### DESIGN PRINCIPLES MET

| Principle | Validation |
|-----------|-----------|
| **Exchange-Defined Calendar** | ✅ NseHolidayCalendar owns truth |
| **Provider-Agnostic** | ✅ Calendar independent of Yahoo Finance |
| **Minimal Design** | ✅ ~500 LOC total, no persistence layer |
| **Trading Days Only** | ✅ Simulation advances through isTradingDay() only |
| **Forward-Only Simulation** | ✅ tradingOffset += 1, no rewind |
| **Calendar Correctness** | ✅ SessionType.isTradingSession() enum guards |
| **Graceful Degradation** | ✅ Missing holidays → provider-detected, not system failure |
| **Extensibility** | ✅ SessionType ready for metadata, calendar injectable |
| **Safety Bounds** | ✅ 100-year limits prevent infinite loops |
| **Audit Trail** | ✅ All admin actions logged |

---

### OUT OF SCOPE (EXPLICITLY EXCLUDED)

- ❌ Forward return engine
- ❌ Dynamic universe
- ❌ Database calendar table
- ❌ UI holiday management
- ❌ Multi-exchange support (design supports, not v1.5)
- ❌ Holiday auto-sync from exchange API
- ❌ Change ingestion scheduling model
- ❌ Provider detection of holidays

---

### REQUIREMENTS MET

#### User Requirements

1. ✅ Design structure for TradingCalendarService
2. ✅ Design structure for NseHolidayCalendar (hardcoded static)
3. ✅ Define special trading session modeling
4. ✅ Define unexpected shutdown day representation
5. ✅ Propose SimulationState changes (trading offset)
6. ✅ Confirm trading calendar NOT infers from provider
7. ✅ Define addTradingDays() for negative values
8. ✅ Define edge case behavior
9. ✅ Confirm ingestion logic unchanged
10. ✅ Confirm provider switch won't require redesign
11. ✅ Design must support: regular weekdays, holidays, special sessions, unexpected closures
12. ✅ Calendar must be exchange-defined (not provider-defined)
13. ✅ System must remain provider-agnostic
14. ✅ TradingCalendarService must NOT depend on stock_prices table
15. ✅ Keep design minimal but correct

---

### INTEGRATION READINESS

**Ready for Implementation**:
- ✅ SessionType enum (standalone)
- ✅ NseHolidayCalendar component (standalone)
- ✅ TradingCalendarService (depends only on NseHolidayCalendar)
- ✅ SimulationState modifications (backward compatible, additive)
- ✅ SimulationController updates (additive)
- ✅ CalendarConfiguration (new beans, non-breaking)
- ✅ AdminCalendarController (optional, non-breaking)
- ✅ Migration script (safe, additive columns)

**Zero Breaking Changes To**:
- ✓ ExchangeConfiguration
- ✓ ExchangeClock
- ✓ DashboardController
- ✓ ScannerEngine
- ✓ DataIngestionService
- ✓ All indicators/rules

---

### TEST COVERAGE OUTLINE

**Unit Tests** (TradingCalendarService):
- nextTradingDay() skips weekends
- previousTradingDay() skips weekends
- addTradingDays(+N) forward
- addTradingDays(-N) backward
- addTradingDays(0) requires trading day
- tradingDaysBetween() counts correctly
- Emergency closures override calendar

**Integration Tests** (Simulation):
- SimulationState.advanceOneSession() increments offset
- getCurrentDate() uses calendar correctly
- Startup validation rejects non-trading base date
- Reset works

**E2E Tests** (Simulation Flow):
- Advance through weekend → skips
- Advance through holiday → skips
- Admin marks emergency closure → honored
- Provider returns no data for special session → SUCCESS_NO_DATA

---

### FINAL IMPLEMENTATION CHECKLIST

Before coding v1.5:
- [ ] Create `SessionType.java`
- [ ] Create `NseHolidayCalendar.java`
- [ ] Create `TradingCalendarService.java`
- [ ] Create `CalendarConfiguration.java`
- [ ] Update `SimulationState.java` (add tradingOffset, methods)
- [ ] Update `SimulationController.java` (use trading sessions)
- [ ] Create migration SQL
- [ ] Add unit tests for TradingCalendarService
- [ ] Add integration tests for SimulationState
- [ ] Update documentation
- [ ] Tag release as v1.5

---

v1.5 calendar design proposal complete.
