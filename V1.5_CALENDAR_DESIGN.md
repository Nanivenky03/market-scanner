# V1.5 Trading Calendar Foundation — Design Proposal

## 1. TRADING CALENDAR SERVICE STRUCTURE

### 1.1 TradingCalendarService Interface

```java
@Service
public class TradingCalendarService {
    
    /**
     * Returns the session type for a given date.
     * Never depends on price data or provider state.
     */
    public SessionType getSession(LocalDate date)
    
    /**
     * True if date is any trading session (TRADING or SPECIAL_SESSION).
     * False for WEEKEND, HOLIDAY, UNEXPECTED_CLOSURE.
     */
    public boolean isTradingDay(LocalDate date)
    
    /**
     * Next calendar day that contains trading.
     * Throws if date is unlimited future (safety check at 100 years).
     */
    public LocalDate nextTradingDay(LocalDate date)
    
    /**
     * Previous calendar day that contained trading.
     * Throws if date is unlimited past (safety check at 100 years).
     */
    public LocalDate previousTradingDay(LocalDate date)
    
    /**
     * Add N trading sessions (forward or backward).
     * 
     * addTradingDays(2025-01-02, 1)  → 2025-01-03 (next trading day)
     * addTradingDays(2025-01-03, -1) → 2025-01-02 (previous trading day)
     * addTradingDays(2025-01-04, 0)  → 2025-01-04 (must be trading day, else throw)
     */
    public LocalDate addTradingDays(LocalDate date, int tradingDaysCount)
    
    /**
     * Count trading sessions between two dates (inclusive of from, exclusive of to).
     * Used for gap detection logic validation.
     */
    public int tradingDaysBetween(LocalDate from, LocalDate to)
    
    /**
     * Count calendar days between two dates (for compatibility with ingestion).
     * NOT trading-aware — Direct ChronoUnit.DAYS usage.
     * Ingestion uses this, not tradingDaysBetween.
     */
    public long calendarDaysBetween(LocalDate from, LocalDate to)
}
```

### 1.2 Implementation Pattern

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class TradingCalendarService {
    
    private final NseHolidayCalendar nseHolidayCalendar;
    
    @Transactional(readOnly = true)
    public SessionType getSession(LocalDate date) {
        return nseHolidayCalendar.getSession(date);
    }
    
    @Transactional(readOnly = true)
    public boolean isTradingDay(LocalDate date) {
        SessionType session = getSession(date);
        return session == SessionType.TRADING || session == SessionType.SPECIAL_SESSION;
    }
    
    @Transactional(readOnly = true)
    public LocalDate nextTradingDay(LocalDate date) {
        LocalDate current = date.plusDays(1);
        int maxIterations = 100 * 365; // Safety: ~100 years
        int iterations = 0;
        
        while (!isTradingDay(current) && iterations < maxIterations) {
            current = current.plusDays(1);
            iterations++;
        }
        
        if (iterations >= maxIterations) {
            throw new TimelineExhaustedException(
                "No trading day found within 100 years from " + date
            );
        }
        
        return current;
    }
    
    // Similar: previousTradingDay(), addTradingDays(), tradingDaysBetween(), calendarDaysBetween()
}
```

### 1.3 Key Design Decisions

- **No database dependency**: Calendar is fully in-memory (static or loaded once)
- **No price data dependency**: Pure date logic, no queries
- **No provider coupling**: Calendar is exchange-specific, not provider-specific
- **Read-only transactions**: Only querying, never persisting
- **Safety bounds**: 100-year limits prevent infinite loops
- **Clear semantics**: SessionType enum is exhaustive and mutually exclusive

---

## 2. NSE HOLIDAY CALENDAR STRUCTURE

### 2.1 SessionType Enum

```java
public enum SessionType {
    
    /**
     * Regular full trading day (09:15 - 15:30 IST).
     * Data ingestion expected, scanner runs normally.
     */
    TRADING,
    
    /**
     * Special trading session (e.g., Muhurat trading, extended hours).
     * Different rules apply, may be shorter, but IS a trading session.
     * Ingestion can run (provider will return data if available).
     * Scanner behavior depends on configuration.
     */
    SPECIAL_SESSION,
    
    /**
     * Full exchange closure (holidays, national observances).
     * No trading at any time.
     * Provider returns no data.
     * System records SUCCESS_NO_DATA.
     */
    HOLIDAY,
    
    /**
     * Unforeseen closure (earthquake, technical failure, etc.).
     * NOT in regular holiday calendar.
     * Treated same as HOLIDAY by calendar logic.
     * Added dynamically during crisis management.
     */
    UNEXPECTED_CLOSURE,
    
    /**
     * Saturday or Sunday.
     * Inherent non-trading days.
     * Cannot be overridden by calendar entries.
     */
    WEEKEND;
}
```

### 2.2 NseHolidayCalendar Component

```java
@Component
@Slf4j
public class NseHolidayCalendar {
    
    /**
     * Static calendar mapping: LocalDate -> SessionType
     * 
     * Covers:
     * - 2023-2026 holidays (production years)
     * - 2025-01-01 to 2026-12-31 (simulation range)
     * - Key NSE holidays: Diwali, Holi, Independence Day, etc.
     * - Special sessions: Muhurat trading dates
     */
    private static final Map<LocalDate, SessionType> SESSION_CALENDAR = initializeCalendar();
    
    /**
     * CRITICAL: This is the ONLY NSE-specific component.
     * All other logic uses this calendar for truth.
     */
    private static Map<LocalDate, SessionType> initializeCalendar() {
        Map<LocalDate, SessionType> calendar = new HashMap<>();
        
        // 2023 Holidays
        calendar.put(LocalDate.of(2023, 1, 26), SessionType.HOLIDAY);   // Republic Day
        calendar.put(LocalDate.of(2023, 3, 7), SessionType.HOLIDAY);    // Holi
        calendar.put(LocalDate.of(2023, 4, 4), SessionType.HOLIDAY);    // Eid ul-Fitr
        calendar.put(LocalDate.of(2023, 4, 14), SessionType.HOLIDAY);   // Dr Ambedkar Jayanti
        calendar.put(LocalDate.of(2023, 5, 1), SessionType.HOLIDAY);    // May Day
        calendar.put(LocalDate.of(2023, 6, 29), SessionType.HOLIDAY);   // Eid ul-Adha
        calendar.put(LocalDate.of(2023, 8, 15), SessionType.HOLIDAY);   // Independence Day
        calendar.put(LocalDate.of(2023, 9, 19), SessionType.HOLIDAY);   // Ganesh Chaturthi
        calendar.put(LocalDate.of(2023, 10, 2), SessionType.HOLIDAY);   // Gandhi Jayanti
        calendar.put(LocalDate.of(2023, 10, 24), SessionType.HOLIDAY);  // Diwali
        calendar.put(LocalDate.of(2023, 11, 13), SessionType.HOLIDAY);  // Guru Nanak Jayanti
        calendar.put(LocalDate.of(2023, 12, 25), SessionType.HOLIDAY);  // Christmas
        
        // 2023 Muhurat Trading Session (example)
        calendar.put(LocalDate.of(2023, 11, 12), SessionType.SPECIAL_SESSION);
        
        // 2024-2026 Holidays (abbreviated for brevity - full list in actual implementation)
        calendar.put(LocalDate.of(2024, 1, 26), SessionType.HOLIDAY);   // Republic Day
        calendar.put(LocalDate.of(2024, 3, 25), SessionType.HOLIDAY);   // Holi
        calendar.put(LocalDate.of(2024, 8, 15), SessionType.HOLIDAY);   // Independence Day
        calendar.put(LocalDate.of(2024, 10, 12), SessionType.HOLIDAY);  // Dussehra
        calendar.put(LocalDate.of(2024, 11, 1), SessionType.HOLIDAY);   // Diwali
        
        calendar.put(LocalDate.of(2025, 1, 26), SessionType.HOLIDAY);   // Republic Day
        calendar.put(LocalDate.of(2025, 3, 14), SessionType.HOLIDAY);   // Holi
        calendar.put(LocalDate.of(2025, 8, 15), SessionType.HOLIDAY);   // Independence Day
        
        calendar.put(LocalDate.of(2026, 1, 26), SessionType.HOLIDAY);   // Republic Day
        calendar.put(LocalDate.of(2026, 3, 6), SessionType.HOLIDAY);    // Holi
        
        return Collections.unmodifiableMap(calendar);
    }
    
    /**
     * Get session type for a date.
     * 
     * Precedence:
     * 1. If in static calendar → use that
     * 2. If weekday → TRADING
     * 3. If weekend → WEEKEND
     */
    public SessionType getSession(LocalDate date) {
        // Check for explicitly mapped days
        if (SESSION_CALENDAR.containsKey(date)) {
            return SESSION_CALENDAR.get(date);
        }
        
        // Check weekends (inherent non-trading)
        DayOfWeek dayOfWeek = date.getDayOfWeek();
        if (dayOfWeek == DayOfWeek.SATURDAY || dayOfWeek == DayOfWeek.SUNDAY) {
            return SessionType.WEEKEND;
        }
        
        // Default: weekday not in holiday list → trading
        return SessionType.TRADING;
    }
    
    /**
     * Add unexpected closure (emergency API for crisis management).
     * Used by admin endpoints during disasters.
     * Persists to volatile set (resets on app restart).
     */
    private static final Set<LocalDate> emergencyClosures = new HashSet<>();
    
    public void markUnexpectedClosure(LocalDate date) {
        emergencyClosures.add(date);
        log.warn("EMERGENCY: Marked {} as UNEXPECTED_CLOSURE", date);
    }
    
    public void clearUnexpectedClosure(LocalDate date) {
        emergencyClosures.remove(date);
        log.warn("CLEARED: Removed {} from UNEXPECTED_CLOSURE", date);
    }
}
```

### 2.3 Special Trading Sessions Design

**Muhurat Trading (Example)**:
```java
// In NseHolidayCalendar.initializeCalendar():
calendar.put(LocalDate.of(2023, 11, 12), SessionType.SPECIAL_SESSION);
calendar.put(LocalDate.of(2024, 11, 1), SessionType.SPECIAL_SESSION);
```

**Characteristics**:
- Marked with `SPECIAL_SESSION` in calendar
- `isTradingDay()` returns true (special sessions ARE trading)
- Provider still fetches data (Yahoo may return limited data for short sessions)
- Scanner behavior configurable: process as normal or skip based on config flag
- Ingestion logic unchanged: attempts fetch, handles no-data gracefully

**Future Enhancements** (out of v1.5 scope):
- SessionMetadata: start time, end time, special rules
- Scanner configuration: "skip.special.sessions=true"

---

## 3. UNEXPECTED SHUTDOWN DAY REPRESENTATION

### 3.1 Two-Layer Model

**Layer 1: Static Calendar** (NSE schedule, known holidays)
```java
// In NseHolidayCalendar.SESSION_CALENDAR
// Covers all regular holidays, Muhurat sessions
```

**Layer 2: Runtime Volatile Set** (Emergency closures)
```java
// In NseHolidayCalendar.emergencyClosures
// Added during crisis via admin API
// Cleared when cache purges or app restarts
```

### 3.2 Update Flow

```java
// Admin endpoint (only in crisis)
@PostMapping("/admin/emergency/mark-closure")
public void markEmergencyClosure(@RequestParam LocalDate date) {
    nseHolidayCalendar.markUnexpectedClosure(date);
    log.warn("MARKED: {} as UNEXPECTED_CLOSURE", date);
}

// TradingCalendarService.getSession() checks both layers:
public SessionType getSession(LocalDate date) {
    if (emergencyClosures.contains(date)) {
        return SessionType.UNEXPECTED_CLOSURE;
    }
    if (SESSION_CALENDAR.containsKey(date)) {
        return SESSION_CALENDAR.get(date);
    }
    if (isWeekend(date)) {
        return SessionType.WEEKEND;
    }
    return SessionType.TRADING;
}
```

### 3.3 Design Rationale

- **Runtime flexibility** without database changes
- **Resets on restart** (acceptable for emergency use)
- **No persistence** (prevents stale crisis markers)
- **Audit trail in logs** (critical events logged)

---

## 4. SIMULATION STATE REDESIGN

### 4.1 Current State (Audit Finding)

```java
@Entity
@Table(name = "simulation_state")
public class SimulationState {
    private LocalDate baseDate;      // 2025-01-01
    private Integer offsetDays;       // 0, 1, 2, ...
    
    public LocalDate getCurrentDate() {
        return baseDate.plusDays(offsetDays);  // CALENDAR MATH
    }
}
```

**Problem**: Advances through weekends/holidays (calendar days, not trading days)

### 4.2 Proposed State (Option A: Trading Days)

```java
@Entity
@Table(name = "simulation_state")
public class SimulationState {
    
    @Id
    private Integer id; // Always 1
    
    @Column(name = "base_date", nullable = false, columnDefinition = "TEXT")
    @Convert(converter = LocalDateConverter.class)
    private LocalDate baseDate;  // Reference point: 2025-01-02 (Friday)
    
    @Column(name = "trading_offset", nullable = false)
    private Integer tradingOffset;  // Sessions since base: 0, 1, 2, ...
    
    /**
     * Calculate current simulated date using trading calendar.
     * 
     * addTradingDays(baseDate, tradingOffset) → current trading date
     * 
     * Example:
     * baseDate = 2025-01-02 (Fri)
     * tradingOffset = 0 → 2025-01-02 (Fri)
     * tradingOffset = 1 → 2025-01-03 (Mon) [skips Sat, Sun]
     * tradingOffset = 2 → 2025-01-06 (Tue) if 2025-01-04 is Sat
     */
    public LocalDate getCurrentDate(TradingCalendarService calendar) {
        if (tradingOffset == 0) {
            return baseDate;
        }
        return calendar.addTradingDays(baseDate, tradingOffset);
    }
    
    /**
     * Advance by one trading session.
     */
    public void advanceOneSession(TradingCalendarService calendar) {
        this.tradingOffset += 1;
    }
    
    /**
     * Fast-forward to specific trading day from base.
     */
    public void toTradingDay(LocalDate targetDate, TradingCalendarService calendar) {
        int offset = calendar.tradingDaysBetween(baseDate, targetDate);
        if (offset < 0) {
            throw new IllegalStateException("Cannot rewind: " + targetDate + " is before base");
        }
        this.tradingOffset = offset;
    }
    
    /**
     * Reset to base date (testing only).
     */
    public void reset() {
        this.tradingOffset = 0;
    }
}
```

### 4.3 Rationale for Trading Offset

✅ **Advantages**:
- Simulation naturally respects exchange calendar
- Clear semantics: "we've had N trading sessions"
- Prevents advancing through non-trading days
- Works unchanged if holiday calendar updates
- Forwards-only semantics maintained

✅ **Compatibility**:
- Ingestion logic unchanged (uses calendar.calendarDaysBetween, not trading days)
- Scanner logic unchanged (uses calendar dates, not offsets)
- Only simulation controller changes

---

## 5. CONFIRMING DESIGN REQUIREMENTS

### 5.1 Trading Calendar Doesn't Infer from Provider

✅ **CONFIRMED**: Calendar is fully independent

- Static map + weekend logic only
- Zero dependency on `stock_prices` table
- Zero dependency on provider API
- `NseHolidayCalendar` has no repository access
- Information flows: Calendar → Ingestion (not reverse)

```java
// ✗ NEVER happens
priceRepository.findByDate(date);  // Never used in calendar

// ✓ ALWAYS happens
SessionType session = calendar.getSession(date);  // Truth source
```

### 5.2 addTradingDays() Behavior for Negative Values

```java
public LocalDate addTradingDays(LocalDate date, int tradingDaysCount) {
    
    // Case 1: Zero offset
    if (tradingDaysCount == 0) {
        if (!isTradingDay(date)) {
            throw new IllegalStateException(
                date + " is not a trading day. Cannot add 0 days."
            );
        }
        return date;
    }
    
    // Case 2: Positive offset
    if (tradingDaysCount > 0) {
        LocalDate current = date;
        for (int i = 0; i < tradingDaysCount; i++) {
            current = nextTradingDay(current);
        }
        return current;
    }
    
    // Case 3: Negative offset (backward traversal)
    if (tradingDaysCount < 0) {
        LocalDate current = date;
        for (int i = 0; i < Math.abs(tradingDaysCount); i++) {
            current = previousTradingDay(current);
        }
        return current;
    }
}

// Examples:
addTradingDays(2025-01-03, -1)  // 2025-01-03 (Fri) → 2025-01-02 (Thu)
addTradingDays(2025-01-03, -2)  // 2025-01-03 (Fri) → 2025-01-02 (Thu) → 2025-01-01 (Wed)
addTradingDays(2025-01-04, -1)  // ERROR: 2025-01-04 is Saturday, not trading day
```

### 5.3 Edge Case Handling

#### Edge Case 1: Startup on Non-Trading Day

**Scenario**: App starts with base date = 2025-01-04 (Saturday)

**Handling**:
```java
@PostConstruct
public void validateInitialState() {
    if (!calendar.isTradingDay(state.getBaseDate())) {
        log.error("CRITICAL: Base date {} is not a trading day", state.getBaseDate());
        log.error("Trading calendar indicates: {}", calendar.getSession(state.getBaseDate()));
        throw new InvalidSimulationStateException(
            "Base date must be a trading day. Got: " + state.getBaseDate()
        );
    }
}
```

**User Action**: Set `simulation.baseDate` to next trading day in properties

#### Edge Case 2: Incomplete Holiday List

**Scenario**: Holiday list misses an unannounced closure

**Handling**:
```
1. Calendar calls date "TRADING"
2. Ingestion attempts fetch
3. Provider returns no data
4. System: SUCCESS_NO_DATA (correct)
5. Next day: Calendar advances, ingestion retries
6. Admin marks with markUnexpectedClosure(date) if needed
```

**Result**: Gracefully degraded, no system failure

#### Edge Case 3: Holiday List Becomes Stale

**Scenario**: 2027 holidays not yet added to static calendar

**Handling**:
```
1. System treats unrecognized dates as TRADING
2. Provider returns no data if actually a holiday
3. System marks SUCCESS_NO_DATA
4. Manual fix: Update NseHolidayCalendar.SESSION_CALENDAR (requires restart)
```

**Acceptable** because:
- Holidays are known months in advance typically
- Worst case: one day of "wrong" classification
- No data corruption
- Audit trail shows attempt

### 5.4 Ingestion Logic Remains Unchanged

**CONFIRMED**: Ingestion is calendar-agnostic

```java
// Current logic (DataIngestionService.java)
long daysSinceLastData = ChronoUnit.DAYS.between(latestDate, endDate);

// Remains unchanged in v1.5
// Uses calendar.calendarDaysBetween(latestDate, endDate)
// Still counts ALL days, not just trading days
// Rationale: Provider may have data for any date (holidays, special sessions, etc.)
```

**Why**:
- Ingestion is provider-agnostic
- Provider decides what data exists
- Calendar only controls simulation, not ingestion
- Gap detection works with calendar days (correct)

### 5.5 Provider Switch Won't Require Calendar Redesign

**CONFIRMED**: Calendar architecture supports provider independence

**Current (v1.5)**: NSE only
```java
@Component
public class NseHolidayCalendar { ... }

@Service
public class TradingCalendarService {
    private final NseHolidayCalendar nseHolidayCalendar;  // Injected
}
```

**Future (v1.6+): Multi-exchange support**
```java
// New calendar component
@Component
public class BseHolidayCalendar { ... }

// Abstraction
public interface ExchangeCalendar {
    SessionType getSession(LocalDate date);
}

// Service accepts any calendar
@Service
public class TradingCalendarService {
    private final ExchangeCalendar exchangeCalendar;  // Could be NSE, BSE, NYSE, etc.
}

// Spring configuration selects
@Configuration
public class CalendarConfig {
    @Bean
    public ExchangeCalendar exchangeCalendar() {
        return new NseHolidayCalendar();  // Configurable per environment
    }
}
```

**No changes needed**:
- Ingestion logic (never touches calendar)
- Scanner logic (uses dates, not sessions)
- Simulation logic (uses calendar interface, not NSE-specific)

---

## 6. INTEGRATION POINTS

### 6.1 SimulationController Updates

```java
@PostMapping("/advance-day")
public Map<String, Object> advanceDay() {
    SimulationState state = repository.findById(1).orElseThrow();
    
    LocalDate previousDate = state.getCurrentDate(calendar);
    
    state.advanceOneSession(calendar);  // Trading session, not calendar day
    repository.save(state);
    
    LocalDate newDate = state.getCurrentDate(calendar);
    
    log.info("Advanced from {} to {} ({} trading sessions)",
        previousDate, newDate, state.getTradingOffset());
    
    // Note: Still requires app restart for fixed clock refresh
    return Map.of(
        "success", true,
        "previousDate", previousDate.toString(),
        "currentDate", newDate.toString(),
        "tradingOffset", state.getTradingOffset()
    );
}
```

### 6.2 DashboardController/Scheduler Unchanged

```java
// These remain calendar-agnostic
LocalDate today = config.getTodayInExchangeZone();  // Production time
ScannerEngine.executeDailyScan();  // Works with any date
```

### 6.3 New Admin Endpoints (Emergency Only)

```java
@PostMapping("/admin/emergency/close")
public void markEmergencyClosure(@RequestParam LocalDate date) {
    holidayCalendar.markUnexpectedClosure(date);
}

@PostMapping("/admin/emergency/reopen")
public void clearEmergencyClosure(@RequestParam LocalDate date) {
    holidayCalendar.clearUnexpectedClosure(date);
}
```

---

## 7. TESTING STRATEGY

### 7.1 Unit Tests for TradingCalendarService

```java
@Test
public void testNextTradingDaySkipsWeekend() {
    LocalDate friday = LocalDate.of(2025, 1, 3);
    LocalDate monday = calendar.nextTradingDay(friday);
    assertEquals(LocalDate.of(2025, 1, 6), monday);
}

@Test
public void testPreviousTradingDaySkipsWeekend() {
    LocalDate monday = LocalDate.of(2025, 1, 6);
    LocalDate friday = calendar.previousTradingDay(monday);
    assertEquals(LocalDate.of(2025, 1, 3), friday);
}

@Test
public void testAddTradingDaysWithHoliday() {
    LocalDate thursday = LocalDate.of(2025, 1, 2);  // Before Diwali
    LocalDate result = calendar.addTradingDays(thursday, 3);  // Skip holidays
    // Result depends on whether days between have holidays
}

@Test
public void testNegativeAddTradingDays() {
    LocalDate tuesday = LocalDate.of(2025, 1, 7);
    LocalDate wednesday = calendar.addTradingDays(tuesday, -1);
    assertEquals(LocalDate.of(2025, 1, 6), wednesday);
}
```

### 7.2 Integration Tests for Simulation

```java
@Test
public void testSimulationAdvancesOnlyThroughTradingDays() {
    SimulationState state = new SimulationState();
    state.setBaseDate(LocalDate.of(2025, 1, 2));  // Thursday
    state.setTradingOffset(0);
    
    state.advanceOneSession(calendar);
    assertEquals(LocalDate.of(2025, 1, 3), state.getCurrentDate(calendar));  // Friday
    
    state.advanceOneSession(calendar);
    assertEquals(LocalDate.of(2025, 1, 6), state.getCurrentDate(calendar));  // Monday
}

@Test
public void testEmergencyClosureBlocks() {
    calendar.markUnexpectedClosure(LocalDate.of(2025, 1, 7));  // Tuesday
    
    LocalDate result = calendar.nextTradingDay(LocalDate.of(2025, 1, 6));  // Monday
    assertEquals(LocalDate.of(2025, 1, 8), result);  // Wednesday
}
```

---

## 8. DESIGN SUMMARY TABLE

| Aspect | Design | Rationale |
|--------|--------|-----------|
| **Base Structure** | TradingCalendarService + NseHolidayCalendar | Single Responsibility + Testability |
| **Session Types** | TRADING, SPECIAL_SESSION, HOLIDAY, UNEXPECTED_CLOSURE, WEEKEND | Exhaustive, mutually exclusive |
| **Holiday Storage** | Static map + runtime volatile set | Known holidays immutable, emergency closures flexible |
| **Simulation Offset** | Trading offset (not calendar days) | Natural trading cadence, exchange-aware |
| **Ingestion Logic** | Unchanged (uses calendar days) | Provider-agnostic, backward compatible |
| **Edge Cases** | Exceptions on invalid base, graceful no-data on missing holidays | Safe failures, audit trails |
| **Provider Switch** | Inject different calendar (NSE → BSE → NYSE) | Zero impact on ingestion/scanner/simulation logic |
| **Special Sessions** | SPECIAL_SESSION enum value | Extensible for Muhurat, extended hours, etc. |
| **Emergency Closures** | Runtime volatile set + admin API | Fast crisis response without persistence |

---

## 9. CONSTRAINTS & OUT OF SCOPE

### 9.1 NOT Included in v1.5

- ❌ Database calendar table (static map sufficient)
- ❌ UI for holiday management (admin API only)
- ❌ Forward return engine (deferred to Phase 2)
- ❌ Dynamic universe (out of scope)
- ❌ Multi-exchange support (NSE only, design supports future)
- ❌ Holiday auto-fetch from exchange API (static only)
- ❌ Advance ingestion scheduling (still manual)

### 9.2 Explicitly Minimal Design

- Single calendar component (no microservice)
- No caching layers (static map is instant)
- No background jobs (all synchronous)
- No persistent queue (real-time only)

---

## 10. MIGRATION PATH FROM v1.4

### 10.1 Database Change

```sql
-- Add new column to simulation_state
ALTER TABLE simulation_state 
ADD COLUMN trading_offset INTEGER NOT NULL DEFAULT 0;

-- Backfill: convert calendar days to trading days
-- (Run one-time migration script)
```

### 10.2 Code Changes

1. Add TradingCalendarService
2. Update SimulationState.getCurrentDate() to use calendar
3. Update SimulationController.advanceDay() to call advanceOneSession()
4. Update tests

### 10.3 Backward Compatibility

- ExchangeConfiguration.getTodayInExchangeZone() unchanged
- ScannerEngine unchanged
- DataIngestionService unchanged
- Scheduler unchanged
- Only simulation changes

