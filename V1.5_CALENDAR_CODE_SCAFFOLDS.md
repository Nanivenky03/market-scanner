## V1.5 CALENDAR FOUNDATION — CODE SCAFFOLDS

### Location Structure

```
src/main/java/com/trading/scanner/
├── config/
│   └── CalendarConfiguration.java         (NEW)
├── model/
│   ├── SessionType.java                   (NEW enum)
│   └── SimulationState.java               (MODIFIED)
├── service/
│   ├── calendar/                          (NEW package)
│   │   ├── TradingCalendarService.java    (NEW)
│   │   └── NseHolidayCalendar.java        (NEW)
│   └── data/
│       └── DataIngestionService.java      (UNCHANGED - but compatible)
└── controller/
    └── SimulationController.java          (MODIFIED)
```

---

### SCAFFOLD 1: SessionType Enum

**File**: `src/main/java/com/trading/scanner/model/SessionType.java`

```java
package com.trading.scanner.model;

/**
 * Exchange trading session classification.
 * 
 * Single source of truth for determining whether a date is a trading day.
 */
public enum SessionType {
    
    /**
     * Regular full trading day (NSE: 09:15 - 15:30 IST).
     * Ingestion expected, scanner runs normally.
     */
    TRADING("Trading Day"),
    
    /**
     * Special session with different rules (Muhurat, extended hours, etc.)
     * IS a trading day. Ingestion can run if provider has data.
     * Scanner behavior depends on configuration (may skip).
     */
    SPECIAL_SESSION("Special Trading Session"),
    
    /**
     * Full exchange closure.
     * No trading activity. Provider returns no data.
     * System records SUCCESS_NO_DATA.
     */
    HOLIDAY("Holiday"),
    
    /**
     * Unforeseen emergency closure (earthquake, disaster, etc.)
     * NOT in regular calendar. Added dynamically by admin.
     * Treated same as HOLIDAY for trading purposes.
     */
    UNEXPECTED_CLOSURE("Unexpected Closure"),
    
    /**
     * Inherent non-trading day (Saturday/Sunday).
     * Cannot be overridden by calendar entries.
     */
    WEEKEND("Weekend");
    
    private final String displayName;
    
    SessionType(String displayName) {
        this.displayName = displayName;
    }
    
    public String getDisplayName() {
        return displayName;
    }
    
    /**
     * True if this session type permits trading activity.
     */
    public boolean isTradingSession() {
        return this == TRADING || this == SPECIAL_SESSION;
    }
}
```

---

### SCAFFOLD 2: NseHolidayCalendar Component

**File**: `src/main/java/com/trading/scanner/service/calendar/NseHolidayCalendar.java`

```java
package com.trading.scanner.service.calendar;

import com.trading.scanner.model.SessionType;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.util.*;

/**
 * NSE Holiday Calendar — Static Model
 * 
 * CRITICAL: This is the ONLY NSE-specific component in the system.
 * 
 * - No database dependencies
 * - No provider dependencies
 * - No price table queries
 * 
 * All other components delegate to this for trading day truth.
 */
@Slf4j
@Component
public class NseHolidayCalendar {
    
    /**
     * Static, immutable calendar mapping: LocalDate → SessionType
     * 
     * Covers:
     * - 2023-2026 NSE holidays (production + simulation years)
     * - Special trading sessions (Muhurat, etc.)
     * - National observances specific to India
     */
    private static final Map<LocalDate, SessionType> SESSION_CALENDAR = 
        Collections.unmodifiableMap(initializeCalendar());
    
    /**
     * Runtime volatile set for emergency closures.
     * - Added during crisis via admin API
     * - Cleared when app restarts
     * - No database persistence
     * - Prevents stale crisis markers
     */
    private final Set<LocalDate> emergencyClosures = new HashSet<>();
    
    /**
     * Get the session type for a specific date.
     * 
     * Precedence:
     * 1. Emergency closures (admin-marked)
     * 2. Static calendar entries
     * 3. Weekends (inherent)
     * 4. Default: TRADING
     * 
     * @param date Date to classify
     * @return SessionType (never null)
     */
    public SessionType getSession(LocalDate date) {
        // Layer 1: Emergency closures (highest priority)
        if (emergencyClosures.contains(date)) {
            return SessionType.UNEXPECTED_CLOSURE;
        }
        
        // Layer 2: Static calendar
        if (SESSION_CALENDAR.containsKey(date)) {
            return SESSION_CALENDAR.get(date);
        }
        
        // Layer 3: Weekends (inherent, cannot be overridden)
        DayOfWeek dayOfWeek = date.getDayOfWeek();
        if (dayOfWeek == DayOfWeek.SATURDAY || dayOfWeek == DayOfWeek.SUNDAY) {
            return SessionType.WEEKEND;
        }
        
        // Layer 4: Default to trading
        return SessionType.TRADING;
    }
    
    /**
     * Mark a date as an emergency closure.
     * Used by admin during crisis (earthquakes, technical failures, etc.)
     * 
     * @param date Date to mark
     */
    public synchronized void markUnexpectedClosure(LocalDate date) {
        emergencyClosures.add(date);
        log.warn("EMERGENCY CLOSURE MARKED: {} ({})", date, date.getDayOfWeek());
    }
    
    /**
     * Clear an emergency closure marking.
     * 
     * @param date Date to clear
     */
    public synchronized void clearUnexpectedClosure(LocalDate date) {
        if (emergencyClosures.remove(date)) {
            log.info("EMERGENCY CLOSURE CLEARED: {} ({})", date, date.getDayOfWeek());
        }
    }
    
    /**
     * Get current emergency closures (for auditing/monitoring).
     * 
     * @return Immutable set of currently marked closures
     */
    public Set<LocalDate> getEmergencyClosures() {
        return Collections.unmodifiableSet(new HashSet<>(emergencyClosures));
    }
    
    /**
     * Initialize static calendar for 2023-2026.
     * 
     * Data sources:
     * - NSE official holiday calendar (https://www.nseindia.com/regulations/rules-regulations)
     * - Indian national holidays
     * - Special trading sessions (Muhurat)
     */
    private static Map<LocalDate, SessionType> initializeCalendar() {
        Map<LocalDate, SessionType> calendar = new HashMap<>();
        
        // ============================================================
        // 2023 HOLIDAYS
        // ============================================================
        calendar.put(LocalDate.of(2023, 1, 26), SessionType.HOLIDAY);   // Republic Day
        calendar.put(LocalDate.of(2023, 3, 7), SessionType.HOLIDAY);    // Holi
        calendar.put(LocalDate.of(2023, 4, 4), SessionType.HOLIDAY);    // Eid ul-Fitr (Est.)
        calendar.put(LocalDate.of(2023, 4, 14), SessionType.HOLIDAY);   // Dr Ambedkar Jayanti
        calendar.put(LocalDate.of(2023, 5, 1), SessionType.HOLIDAY);    // May Day
        calendar.put(LocalDate.of(2023, 6, 29), SessionType.HOLIDAY);   // Eid ul-Adha (Est.)
        calendar.put(LocalDate.of(2023, 8, 15), SessionType.HOLIDAY);   // Independence Day
        calendar.put(LocalDate.of(2023, 9, 19), SessionType.HOLIDAY);   // Ganesh Chaturthi
        calendar.put(LocalDate.of(2023, 10, 2), SessionType.HOLIDAY);   // Gandhi Jayanti
        calendar.put(LocalDate.of(2023, 10, 24), SessionType.HOLIDAY);  // Diwali (Day 1)
        calendar.put(LocalDate.of(2023, 11, 13), SessionType.HOLIDAY);  // Guru Nanak Jayanti
        calendar.put(LocalDate.of(2023, 12, 25), SessionType.HOLIDAY);  // Christmas
        
        // 2023 Special Sessions
        calendar.put(LocalDate.of(2023, 11, 12), SessionType.SPECIAL_SESSION);  // Muhurat Trading
        
        // ============================================================
        // 2024 HOLIDAYS
        // ============================================================
        calendar.put(LocalDate.of(2024, 1, 26), SessionType.HOLIDAY);   // Republic Day
        calendar.put(LocalDate.of(2024, 3, 8), SessionType.HOLIDAY);    // Maha Shivaratri
        calendar.put(LocalDate.of(2024, 3, 25), SessionType.HOLIDAY);   // Holi
        calendar.put(LocalDate.of(2024, 3, 29), SessionType.HOLIDAY);   // Good Friday
        calendar.put(LocalDate.of(2024, 4, 11), SessionType.HOLIDAY);   // Eid ul-Fitr (Est.)
        calendar.put(LocalDate.of(2024, 4, 17), SessionType.HOLIDAY);   // Ram Navami
        calendar.put(LocalDate.of(2024, 4, 21), SessionType.HOLIDAY);   // Mahavir Jayanti
        calendar.put(LocalDate.of(2024, 5, 23), SessionType.HOLIDAY);   // Buddha Purnima
        calendar.put(LocalDate.of(2024, 6, 17), SessionType.HOLIDAY);   // Eid ul-Adha (Est.)
        calendar.put(LocalDate.of(2024, 8, 15), SessionType.HOLIDAY);   // Independence Day
        calendar.put(LocalDate.of(2024, 8, 26), SessionType.HOLIDAY);   // Janmashtami
        calendar.put(LocalDate.of(2024, 9, 16), SessionType.HOLIDAY);   // Milad un-Nabi
        calendar.put(LocalDate.of(2024, 10, 2), SessionType.HOLIDAY);   // Gandhi Jayanti
        calendar.put(LocalDate.of(2024, 10, 12), SessionType.HOLIDAY);  // Dussehra
        calendar.put(LocalDate.of(2024, 11, 1), SessionType.HOLIDAY);   // Diwali (Day 1)
        calendar.put(LocalDate.of(2024, 11, 9), SessionType.HOLIDAY);   // Guru Nanak Jayanti
        calendar.put(LocalDate.of(2024, 12, 25), SessionType.HOLIDAY);  // Christmas
        
        // 2024 Special Sessions
        calendar.put(LocalDate.of(2024, 11, 1), SessionType.SPECIAL_SESSION);   // Muhurat Trading (Diwali)
        
        // ============================================================
        // 2025 HOLIDAYS (Current Simulation Base)
        // ============================================================
        calendar.put(LocalDate.of(2025, 1, 26), SessionType.HOLIDAY);   // Republic Day
        calendar.put(LocalDate.of(2025, 2, 28), SessionType.HOLIDAY);   // Maha Shivaratri
        calendar.put(LocalDate.of(2025, 3, 14), SessionType.HOLIDAY);   // Holi
        calendar.put(LocalDate.of(2025, 4, 18), SessionType.HOLIDAY);   // Good Friday
        calendar.put(LocalDate.of(2025, 4, 18), SessionType.HOLIDAY);   // Eid ul-Fitr (Est.)
        calendar.put(LocalDate.of(2025, 4, 29), SessionType.HOLIDAY);   // Mahavir Jayanti
        calendar.put(LocalDate.of(2025, 5, 23), SessionType.HOLIDAY);   // Buddha Purnima
        calendar.put(LocalDate.of(2025, 6, 7), SessionType.HOLIDAY);    // Eid ul-Adha (Est.)
        calendar.put(LocalDate.of(2025, 8, 15), SessionType.HOLIDAY);   // Independence Day
        calendar.put(LocalDate.of(2025, 9, 16), SessionType.HOLIDAY);   // Milad un-Nabi
        calendar.put(LocalDate.of(2025, 10, 2), SessionType.HOLIDAY);   // Gandhi Jayanti
        calendar.put(LocalDate.of(2025, 10, 20), SessionType.HOLIDAY);  // Dussehra
        calendar.put(LocalDate.of(2025, 10, 24), SessionType.HOLIDAY);  // Diwali (Day 1)
        calendar.put(LocalDate.of(2025, 11, 25), SessionType.HOLIDAY);  // Guru Nanak Jayanti
        calendar.put(LocalDate.of(2025, 12, 25), SessionType.HOLIDAY);  // Christmas
        
        // 2025 Special Sessions
        calendar.put(LocalDate.of(2025, 10, 24), SessionType.SPECIAL_SESSION);  // Muhurat Trading (Diwali)
        
        // ============================================================
        // 2026 HOLIDAYS (Future Extension)
        // ============================================================
        calendar.put(LocalDate.of(2026, 1, 26), SessionType.HOLIDAY);   // Republic Day
        calendar.put(LocalDate.of(2026, 3, 6), SessionType.HOLIDAY);    // Holi
        calendar.put(LocalDate.of(2026, 4, 10), SessionType.HOLIDAY);   // Good Friday
        calendar.put(LocalDate.of(2026, 4, 10), SessionType.HOLIDAY);   // Eid ul-Fitr (Est.)
        calendar.put(LocalDate.of(2026, 5, 1), SessionType.HOLIDAY);    // May Day
        calendar.put(LocalDate.of(2026, 8, 15), SessionType.HOLIDAY);   // Independence Day
        calendar.put(LocalDate.of(2026, 10, 2), SessionType.HOLIDAY);   // Gandhi Jayanti
        calendar.put(LocalDate.of(2026, 11, 13), SessionType.HOLIDAY);  // Diwali (Est.)
        calendar.put(LocalDate.of(2026, 12, 25), SessionType.HOLIDAY);  // Christmas
        
        return calendar;
    }
}
```

---

### SCAFFOLD 3: TradingCalendarService

**File**: `src/main/java/com/trading/scanner/service/calendar/TradingCalendarService.java`

```java
package com.trading.scanner.service.calendar;

import com.trading.scanner.model.SessionType;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.ChronoUnit;
import java.time.LocalDate;

/**
 * Trading Calendar Service — Exchange-Aware Date Utilities
 * 
 * All trading day calculations go through this service.
 * 
 * Key Properties:
 * - NSE-specific (2025: NSE only, future: injectable)
 * - Calendar-aware (trading days ≠ calendar days)
 * - Provider-agnostic (never queries stock_prices)
 * - Stateless (no database dependencies)
 * - Immutable (read-only @Transactional)
 */
@Slf4j
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class TradingCalendarService {
    
    private final NseHolidayCalendar nseHolidayCalendar;
    
    /**
     * Get session type for a date.
     * 
     * @param date Date to classify
     * @return SessionType (TRADING, HOLIDAY, WEEKEND, etc.)
     */
    public SessionType getSession(LocalDate date) {
        return nseHolidayCalendar.getSession(date);
    }
    
    /**
     * True if date is a trading day (TRADING or SPECIAL_SESSION).
     * False for WEEKEND, HOLIDAY, UNEXPECTED_CLOSURE.
     * 
     * @param date Date to check
     * @return true if trading, false if non-trading
     */
    public boolean isTradingDay(LocalDate date) {
        SessionType session = getSession(date);
        return session.isTradingSession();
    }
    
    /**
     * Get next trading day after the given date.
     * 
     * If date is trading day → returns next day's trading session.
     * If date is non-trading day → returns next trading session.
     * 
     * @param date Starting date
     * @return Next trading day
     * @throws TimelineExhaustedException if no trading day found in 100 years
     */
    public LocalDate nextTradingDay(LocalDate date) {
        LocalDate current = date.plusDays(1);
        int maxIterations = 100 * 365; // ~100 years safety bound
        int iterations = 0;
        
        while (!isTradingDay(current) && iterations < maxIterations) {
            current = current.plusDays(1);
            iterations++;
        }
        
        if (iterations >= maxIterations) {
            throw new TimelineExhaustedException(
                "No trading day found within 100 years from " + date
            );
        }
        
        log.debug("Next trading day after {}: {}", date, current);
        return current;
    }
    
    /**
     * Get previous trading day before the given date.
     * 
     * If date is trading day → returns previous day's trading session.
     * If date is non-trading day → returns previous trading session.
     * 
     * @param date Starting date
     * @return Previous trading day
     * @throws TimelineExhaustedException if no trading day found in 100 years
     */
    public LocalDate previousTradingDay(LocalDate date) {
        LocalDate current = date.minusDays(1);
        int maxIterations = 100 * 365; // ~100 years safety bound
        int iterations = 0;
        
        while (!isTradingDay(current) && iterations < maxIterations) {
            current = current.minusDays(1);
            iterations++;
        }
        
        if (iterations >= maxIterations) {
            throw new TimelineExhaustedException(
                "No trading day found within 100 years before " + date
            );
        }
        
        log.debug("Previous trading day before {}: {}", date, current);
        return current;
    }
    
    /**
     * Add N trading sessions to a date (forward or backward).
     * 
     * Cases:
     * - addTradingDays(fri, 1)   → next monday (skips weekend)
     * - addTradingDays(fri, -1)  → previous thursday
     * - addTradingDays(fri, 0)   → friday (must be trading day, else error)
     * 
     * @param date Starting date
     * @param tradingDaysCount Number of sessions (positive→forward, negative→backward, 0→same date)
     * @return Date after adding N trading days
     * @throws IllegalStateException if date is not a trading day when count=0
     * @throws TimelineExhaustedException if out of bounds
     */
    public LocalDate addTradingDays(LocalDate date, int tradingDaysCount) {
        // Case 1: Zero offset
        if (tradingDaysCount == 0) {
            if (!isTradingDay(date)) {
                throw new IllegalStateException(
                    date + " is " + getSession(date) + ", not a trading day. Cannot add 0 days."
                );
            }
            return date;
        }
        
        // Case 2: Positive offset (forward)
        if (tradingDaysCount > 0) {
            LocalDate current = date;
            for (int i = 0; i < tradingDaysCount; i++) {
                current = nextTradingDay(current);
            }
            log.debug("Added {} trading days: {} → {}", tradingDaysCount, date, current);
            return current;
        }
        
        // Case 3: Negative offset (backward)
        LocalDate current = date;
        for (int i = 0; i < Math.abs(tradingDaysCount); i++) {
            current = previousTradingDay(current);
        }
        log.debug("Added {} trading days (negative): {} → {}", tradingDaysCount, date, current);
        return current;
    }
    
    /**
     * Count trading sessions between two dates (inclusive from, exclusive to).
     * 
     * Examples:
     * - tradingDaysBetween(Mon, Tue)      → 1 (Mon is trading)
     * - tradingDaysBetween(Fri, Mon)      → 1 (Fri is trading, skips Sat-Sun)
     * - tradingDaysBetween(Fri, Tue)      → 1 (only Fri)
     * - tradingDaysBetween(Mon, Wed+holiday) → some number
     * 
     * @param from Start date (inclusive)
     * @param to End date (exclusive)
     * @return Count of trading sessions
     */
    public int tradingDaysBetween(LocalDate from, LocalDate to) {
        if (from.isAfter(to)) {
            throw new IllegalArgumentException("from (" + from + ") must be ≤ to (" + to + ")");
        }
        
        int count = 0;
        LocalDate current = from;
        
        while (current.isBefore(to)) {
            if (isTradingDay(current)) {
                count++;
            }
            current = current.plusDays(1);
        }
        
        return count;
    }
    
    /**
     * Count calendar days between two dates (not trading-aware).
     * 
     * Used for ingestion gap detection (provider-agnostic count).
     * Not filtered by trading calendar.
     * 
     * @param from Start date
     * @param to End date
     * @return Calendar days (using ChronoUnit.DAYS)
     */
    public long calendarDaysBetween(LocalDate from, LocalDate to) {
        return ChronoUnit.DAYS.between(from, to);
    }
    
    /**
     * Exception: Timeline lookup exceeded safety bounds.
     */
    public static class TimelineExhaustedException extends RuntimeException {
        public TimelineExhaustedException(String message) {
            super(message);
        }
    }
}
```

---

### SCAFFOLD 4: SimulationState (Updated)

**File**: `src/main/java/com/trading/scanner/model/SimulationState.java` (MODIFIED)

```java
package com.trading.scanner.model;

import com.trading.scanner.config.LocalDateConverter;
import com.trading.scanner.service.calendar.TradingCalendarService;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDate;

/**
 * Simulation State — Trading Session Timeline
 * 
 * UPDATED FOR V1.5: Now tracks trading sessions, not calendar days.
 * 
 * Model: SimulatedDate = calendar.addTradingDays(baseDate, tradingOffset)
 * 
 * Single-row table (id=1). Persists timeline position across restarts.
 */
@Entity
@Table(name = "simulation_state")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class SimulationState {
    
    @Id
    private Integer id; // Always 1
    
    /**
     * Reference point for simulation.
     * Must be a trading day.
     * Example: 2025-01-02 (Friday)
     */
    @Column(name = "base_date", nullable = false, columnDefinition = "TEXT")
    @Convert(converter = LocalDateConverter.class)
    private LocalDate baseDate;
    
    /**
     * Number of trading sessions elapsed since baseDate.
     * 
     * tradingOffset = 0 → baseDate itself
     * tradingOffset = 1 → next trading day
     * tradingOffset = 2 → 2 trading days later (skips weekends/holidays)
     * 
     * Example sequence:
     * baseDate = 2025-01-02 (Fri)
     * offset=0 → 2025-01-02 (Fri)
     * offset=1 → 2025-01-03 (Mon) [skips Sat, Sun]
     * offset=2 → 2025-01-06 (Tue)
     */
    @Column(name = "trading_offset", nullable = false)
    private Integer tradingOffset;
    
    /**
     * Calculate current simulated date using trading calendar.
     * 
     * CRITICAL: Requires TradingCalendarService for execution.
     * Called by SimulationController to determine current simulation date.
     * 
     * @param calendar TradingCalendarService instance
     * @return Current simulated trading day
     */
    public LocalDate getCurrentDate(TradingCalendarService calendar) {
        if (tradingOffset == 0) {
            return baseDate;
        }
        return calendar.addTradingDays(baseDate, tradingOffset);
    }
    
    /**
     * Advance by exactly one trading session.
     * 
     * Called by SimulationController after each step.
     * Must be followed by app restart (fixed clock issue).
     */
    public void advanceOneSession() {
        this.tradingOffset += 1;
    }
    
    /**
     * Fast-forward to a target trading day from base.
     * 
     * Calculates offset needed to reach target date.
     * Error if target is before base (no rewinding).
     * 
     * @param targetDate Target simulation date
     * @param calendar TradingCalendarService instance
     * @throws IllegalStateException if target is before base
     */
    public void toTradingDay(LocalDate targetDate, TradingCalendarService calendar) {
        if (targetDate.isBefore(baseDate)) {
            throw new IllegalStateException(
                "Cannot rewind: target " + targetDate + " is before base " + baseDate
            );
        }
        int offset = calendar.tradingDaysBetween(baseDate, targetDate);
        if (offset < 0) {
            throw new IllegalStateException(
                "Target " + targetDate + " is not reachable from base " + baseDate
            );
        }
        this.tradingOffset = offset;
    }
    
    /**
     * Reset to base date (offset = 0).
     * 
     * TESTING ONLY — marked as dangerous.
     */
    public void resetToBase() {
        this.tradingOffset = 0;
    }
    
    /**
     * Validate that base date is a trading day.
     * Called on initialization.
     * 
     * @param calendar TradingCalendarService instance
     * @throws IllegalStateException if base is not trading day
     */
    public void validateBaseDate(TradingCalendarService calendar) {
        if (!calendar.isTradingDay(baseDate)) {
            throw new IllegalStateException(
                "Base date " + baseDate + " is " + calendar.getSession(baseDate) 
                + ", not a trading day"
            );
        }
    }
}
```

---

### SCAFFOLD 5: SimulationController (Updated)

**File**: `src/main/java/com/trading/scanner/controller/SimulationController.java` (MODIFIED)

```java
@PostMapping("/advance-day")
public Map<String, Object> advanceDay() {
    SimulationState state = simulationStateRepository.findById(1)
        .orElseThrow(() -> new RuntimeException("Simulation state not initialized"));
    
    LocalDate previousDate = state.getCurrentDate(tradingCalendar);
    
    // Advance by ONE trading session (not calendar day)
    state.advanceOneSession();
    simulationStateRepository.save(state);
    
    LocalDate newDate = state.getCurrentDate(tradingCalendar);
    SessionType nextSession = tradingCalendar.getSession(newDate);
    
    log.info("SIMULATION: Advanced from {} to {} ({}) [offset: {}]",
        previousDate, newDate, nextSession.getDisplayName(), state.getTradingOffset());
    
    Map<String, Object> response = new HashMap<>();
    response.put("success", true);
    response.put("previousDate", previousDate.toString());
    response.put("currentDate", newDate.toString());
    response.put("sessionType", nextSession.name());
    response.put("tradingOffset", state.getTradingOffset());
    response.put("message", "Advanced one trading session. Restart app to load new date.");
    
    return response;
}

@PostMapping("/fast-forward")
public Map<String, Object> fastForward(@RequestParam LocalDate targetDate) {
    SimulationState state = simulationStateRepository.findById(1)
        .orElseThrow(() -> new RuntimeException("Simulation state not initialized"));
    
    if (!tradingCalendar.isTradingDay(targetDate)) {
        throw new IllegalArgumentException(
            targetDate + " is not a trading day: " + tradingCalendar.getSession(targetDate)
        );
    }
    
    LocalDate previousDate = state.getCurrentDate(tradingCalendar);
    state.toTradingDay(targetDate, tradingCalendar);
    simulationStateRepository.save(state);
    
    log.info("SIMULATION: Fast-forwarded from {} to {} (offset: {})",
        previousDate, targetDate, state.getTradingOffset());
    
    Map<String, Object> response = new HashMap<>();
    response.put("success", true);
    response.put("previousDate", previousDate.toString());
    response.put("targetDate", targetDate.toString());
    response.put("tradingOffset", state.getTradingOffset());
    response.put("message", "Fast-forwarded to target trading day. Restart app.");
    
    return response;
}

@PostMapping("/reset")
public Map<String, Object> reset() {
    SimulationState state = simulationStateRepository.findById(1)
        .orElseThrow(() -> new RuntimeException("Simulation state not initialized"));
    
    state.resetToBase();
    simulationStateRepository.save(state);
    
    log.warn("SIMULATION: Reset to base date {}", state.getBaseDate());
    
    Map<String, Object> response = new HashMap<>();
    response.put("success", true);
    response.put("baseDate", state.getBaseDate().toString());
    response.put("currentDate", state.getCurrentDate(tradingCalendar).toString());
    response.put("message", "Reset to base. Restart app.");
    
    return response;
}

@GetMapping("/status")
public Map<String, Object> getStatus() {
    SimulationState state = simulationStateRepository.findById(1)
        .orElseThrow(() -> new RuntimeException("Simulation state not initialized"));
    
    LocalDate currentDate = state.getCurrentDate(tradingCalendar);
    SessionType session = tradingCalendar.getSession(currentDate);
    
    Map<String, Object> status = new HashMap<>();
    status.put("baseDate", state.getBaseDate().toString());
    status.put("tradingOffset", state.getTradingOffset());
    status.put("currentDate", currentDate.toString());
    status.put("sessionType", session.name());
    status.put("sessionDisplay", session.getDisplayName());
    status.put("isTradingDay", session.isTradingSession());
    
    return status;
}
```

---

### SCAFFOLD 6: CalendarConfiguration (New)

**File**: `src/main/java/com/trading/scanner/config/CalendarConfiguration.java`

```java
package com.trading.scanner.config;

import com.trading.scanner.service.calendar.NseHolidayCalendar;
import com.trading.scanner.service.calendar.TradingCalendarService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * Calendar Configuration — Dependency Injection Setup
 * 
 * Registers calendar components for injection into services.
 */
@Configuration
public class CalendarConfiguration {
    
    @Bean
    public NseHolidayCalendar nseHolidayCalendar() {
        return new NseHolidayCalendar();
    }
    
    @Bean
    public TradingCalendarService tradingCalendarService(NseHolidayCalendar nseHolidayCalendar) {
        return new TradingCalendarService(nseHolidayCalendar);
    }
}
```

---

### SCAFFOLD 7: Admin Emergency API (Optional Extension)

**File**: `src/main/java/com/trading/scanner/controller/AdminCalendarController.java` (NEW)

```java
@RestController
@RequestMapping("/admin/calendar")
@RequiredArgsConstructor
@Slf4j
public class AdminCalendarController {
    
    private final NseHolidayCalendar holiday Calendar;
    
    /**
     * Emergency: Mark a date as unexpected closure.
     * 
     * Usage: curl -X POST http://localhost:8080/admin/calendar/emergency-close \
     *          -d "date=2025-02-15"
     */
    @PostMapping("/emergency-close")
    public Map<String, Object> markEmergencyClosure(@RequestParam LocalDate date) {
        holidayCalendar.markUnexpectedClosure(date);
        
        Map<String, Object> response = new HashMap<>();
        response.put("success", true);
        response.put("date", date.toString());
        response.put("marked", "UNEXPECTED_CLOSURE");
        response.put("message", "Date marked as emergency closure");
        
        return response;
    }
    
    /**
     * Emergency: Clear an unexpected closure marking.
     */
    @PostMapping("/emergency-clear")
    public Map<String, Object> clearEmergencyClosure(@RequestParam LocalDate date) {
        holidayCalendar.clearUnexpectedClosure(date);
        
        Map<String, Object> response = new HashMap<>();
        response.put("success", true);
        response.put("date", date.toString());
        response.put("message", "Emergency closure cleared");
        
        return response;
    }
    
    /**
     * View current emergency closures.
     */
    @GetMapping("/emergency-closures")
    public Map<String, Object> listEmergencyClosures() {
        Set<LocalDate> closures = holidayCalendar.getEmergencyClosures();
        
        Map<String, Object> response = new HashMap<>();
        response.put("count", closures.size());
        response.put("dates", closures.stream()
            .sorted()
            .map(LocalDate::toString)
            .toList());
        
        return response;
    }
}
```

---

## MIGRATION SQL

**File**: `scripts/migration_v1.5_calendar.sql`

```sql
-- V1.5 Calendar Migration: Add trading offset to simulation_state

ALTER TABLE simulation_state 
ADD COLUMN trading_offset INTEGER NOT NULL DEFAULT 0;

-- Backfill: Convert calendar days to trading days using static calendar
-- This requires a one-time manual calculation based on NseHolidayCalendar

-- Example for 2025-01-08 baseline:
-- - baseDate = 2025-01-02 (Friday)
-- - Actual stored date = 2025-01-08 (Wednesday)
-- - Trading days between = calculate using calendar

-- Temporary: Set to 0, then admin can call fast-forward if needed
UPDATE simulation_state SET trading_offset = 0 WHERE id = 1;

-- Verify
SELECT id, base_date, trading_offset FROM simulation_state;
```

---

## FILE MAPPING SUMMARY

New Files Created:
```
✅ src/main/java/com/trading/scanner/model/SessionType.java
✅ src/main/java/com/trading/scanner/service/calendar/NseHolidayCalendar.java
✅ src/main/java/com/trading/scanner/service/calendar/TradingCalendarService.java
✅ src/main/java/com/trading/scanner/config/CalendarConfiguration.java
✅ src/main/java/com/trading/scanner/controller/AdminCalendarController.java (optional)
✅ scripts/migration_v1.5_calendar.sql
```

Files Modified:
```
✏️ src/main/java/com/trading/scanner/model/SimulationState.java
✏️ src/main/java/com/trading/scanner/controller/SimulationController.java
```

Files Unchanged:
```
✓ DataIngestionService (calendar-agnostic, no changes needed)
✓ ScannerEngine (calendar-agnostic, no changes needed)
✓ ExchangeConfiguration (no changes needed)
✓ ExchangeClock (no changes needed)
```

